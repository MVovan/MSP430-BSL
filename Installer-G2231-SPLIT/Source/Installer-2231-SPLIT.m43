; Installer-2231-Split.m43

; This is the source code for the installer for the "Split" version of the basic BSL
; (boot-strap loader) for the TI MSP430G2231.  The assembled code should be flashed to the
; 2231 with a Launchpad, and on first run it will "format" the chip for future BSL flashing
; using the Windows console app BSL2231.exe included in this project.
;
; The installer will write the first portion of the BSL code to the bottom of MAIN menory at
; 0xF800-0xF84F, and the second portion into INFOA, INFOB, and INFOC, and change the reset
; vector to point to the BSL entry point at 0xF800.  In addition, the installer determines
; the correct 8, 12 and 16 MHz calibration values and saves all calibration bytes at the top
; of INFOA beginning at 0x10F8.  INFOD is not used by this Split version of BSL.
;
; This code is written for the NAKEN ASSEMBLER written by Michael Kohn.
;    https://www.mikekohn.net/micro/naken_asm.php
; If you wish to make changes, put your revised .m43 and .inc files in the same folder as
; naken_asm.exe, and run that program in a CMD window.  The new assembled code will be in out.hex.
;
; When the G2231 is powered up the first time after flashing this installer, please allow one second
; for it to complete the installation process before touching it or removing power.  By default,
; there is no indication that completion has occurred.  However, there is a commented block of
; code which would set P1.6 as a high output.  So an LED and resistor connected to that port,
; as is the case with the Launchpad, would indicate completion.  This is not enabled by default
; because BSL might be installed in-circuit where P1.6 going high might result in a short.
; To enable the indicator, un-comment that section and reassemble, or just make the following change
; directly to the .hex file for this installer:
;
; Replace:
; :10F9D00010A52C01034303430343034303430343A1
;
; With:
; :10F9D00010A52C01F2D040002100F2D040002200FE
;
; Please note that the calibration process requires a Vcc of at least 3.3V.
;
; The BSL code installed by this software is functionally similar to the version provided by TI
; in MSP430BSL_1_00_12_00.zip.  Differences are described below in the source code for the BSL itself.
;
; Thanks to Steve Gibson for the idea of calibration without using a crystal, and for the
; original code, which is included here with permission.

; *******************************************************************************
;
;  The original version of the BSL code presented below beginning at "BSLCode:" appears
;  in "MSP430BSL_1_00_12_00.zip" which is provided by Texas Instruments, which requires
;  the following notices appearing in the original source code be retained here:
;
;  Copyright (C) 2011 Texas Instruments Incorporated - http://www.ti.com/
;
;  Redistribution and use in source and binary forms, with or without
;  modification, are permitted provided that the following conditions
;  are met:
;
;    Redistributions of source code must retain the above copyright
;    notice, this list of conditions and the following disclaimer.
;
;    Redistributions in binary form must reproduce the above copyright
;    notice, this list of conditions and the following disclaimer in the
;    documentation and/or other materials provided with the
;    distribution.
;
;    Neither the name of Texas Instruments Incorporated nor the names of
;    its contributors may be used to endorse or promote products derived
;    from this software without specific prior written permission.
;
;  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
;  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
;  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
;  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
;  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
;  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
;  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
;  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
;  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
;  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
;  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;
; *******************************************************************************

.msp430

.include "msp430g2231.inc"

BSLENTRY        equ     0xF800                          ;future vector for powerup/reset
BSLIMAGE        equ     0xFC00                          ;image of BSL to relocate to INFO
INFOBASE        equ     0x1040                          ;bottom of INFO
INFOABASE       equ     0x10C0                          ;bottom of INFOA
LPM4            equ     0xF0                            ;Low Power Mode - all off
DoneFlag        equ     0x40                            ;for P1.6, if used

        .org    0xF850

Application:   ;;;; place holder for future applications firmware, which will overwrite this ;;;;;

        bic.w   #GIE,           SR                      ;turn off interrupts
        bis.w   #LPM4,          SR                      ;everything off.

        .org    0xF900

PowerUp:       ;;;; this program starts here on power up ;;;;;;;;;;

        mov.w   #0x0280,        SP                      ;set stack pointer to end of RAM
        mov.w   #WDTPW+WDTHOLD, &WDTCTL                 ;stop WDT, set to timer
        mov.b   #0,             &IFG1                   ;clear all flags

        mov.w   &CALDCO_16MHZ,  &0x0238                 ;preserve 16MHz values
        mov.w   &CALDCO_12MHZ,  &0x023A                 ;preserve 12MHz values
        mov.w   &CALDCO_8MHZ,   &0x023C                 ;preserve 8MHz values
        mov.w   &CALDCO_1MHZ,   &0x023E                 ;preserve 1MHz values

;Set main clock to 8 MHz

        mov.w   &CALDCO_8MHZ,   R5                      ;Already calibrated 8MHz values?
        push    R5
        and.w   #0x0f00,        R5                      ;see if value looks reasonable
        cmp.w   #0x0d00,        R5                      ;range select should be 13 for 8 MHz
        pop     R5
;        jnz     DoCal                                   ;skip clibration if 8 MHz already there
        jmp DoCal                                       ;always do calibration
        mov.b   R5,             &DCOCTL                 ;set clock to 8 MHz
        swpb    R5
        mov.b   R5,             &BCSCTL1
        jmp     Flash

DoCal:

        call    #Calibrate                              ;If not there, do 8MHz calibration

Flash:                                                  ;Copy BSL image and calibration bytes to INFO A-D

        mov.w   #FWKEY+LOCKA,           &FCTL3          ;Unlock for erasing, toggle LOCKA off
        mov.w   #FWKEY+FSSEL_1+21,      &FCTL2          ;MCLK, Div = 21 (22) = 364 KHz at 8 Mhz

        mov.w   #INFOBASE,      R10

Eraseloop:

        mov.w   #FWKEY+ERASE,   &FCTL1                  ;Enable Erase mode (auto-cleared after)
        clr.b   0(R10)                                  ;dummy write to start erase
        add.w   #0x40,          R10                     ;next INFO segment
        cmp.w   #0x10FF,        R10                     ;are we done yet?
        jnc     Eraseloop

        mov.w   #FWKEY+WRT,     &FCTL1                  ;switch from Erase to Write
        mov.w   #BSLIMAGE,      R10
        mov.w   #INFOBASE,      R11
        mov.w   #0x10F8-INFOBASE,    R12                ;BSL image less cal info

XLoop:

        mov.b   @R10+,          0(R11)                  ;Copy BSL image to INFO
        inc.w   R11
        dec.w   R12
        jnz     XLoop

        mov.w   &0x0238,        &CALDCO_16MHZ           ;Copy calibration values to INFOA
        mov.w   &0x023A,        &CALDCO_12MHZ
        mov.w   &0x023C,        &CALDCO_8MHZ            ;Copy calibration values to INFOA
        mov.w   &0x023E,        &CALDCO_1MHZ

        mov.w   #FWKEY,             &FCTL1              ;Turn off Write mode
        mov.w   #FWKEY+LOCK+LOCKA,  &FCTL3              ;Relock flash, toggle LOCKA back on

RES_VEC:                                                ;erase top segment, then
                                                        ;  write reset vector pointing to BSL entry

        mov.w   #FWKEY,         &FCTL3                  ;Unlock flash
        mov.w   #FWKEY+ERASE,   &FCTL1                  ;Enable Erase mode
        clr.b   &0xFE00                                 ;dummy write to start erase
        mov.w   #FWKEY+WRT,     &FCTL1                  ;switch from Erase to Write
        mov.w   #BSLENTRY,      &RESET_VECTOR           ;write BSL entry point as PU/Reset vector
        mov.w   #FWKEY,         &FCTL1                  ;Turn off Write mode
        mov.w   #FWKEY+LOCK,    &FCTL3                  ;Relock flash

; This section would set P1.6 as output high on completion, which would turn on the LED in
; the Launchpad.  But the default version doesn't do that because this software might be
; installed in-circuit, which might produce smoke depending on how P1.6 is being used.
;
;         bis.b   #DoneFlag,      &P1OUT                ;sets P1.6 output high
;         bis.b   #DoneFlag,      &P1DIR

        nop                                             ;these occupy the same space as the two above
        nop
        nop
        nop
        nop
        nop

        bic.w   #GIE,           SR                      ;turn off interrupts
        bis.w   #LPM4,          SR                      ;everything off.

        jmp   $                                         ;just in case we get here

;;;;;;; End of Program ;;;;;;;;;;;;;;;;;;;;;;;;;

RAM             equ     0x0200
INFOD           equ     0x1000
SLOW            equ     0xff
FAST            equ     0

; Calibration register usage

Calword         equ     R5
TotINTs         equ     R9
CurINT          equ     R4
BegCnt          equ     R5
MHzFlag         equ     R13
Delta1          equ     R6
Delta8          equ     R7
Entry           equ     R12
LastEntry       equ     R10
Dir             equ     R14
LastDir         equ     R11
DCOTemp         equ     R5
ABSD8D1         equ     R8


Calibrate:            ;Derives calibrated 8/12/16 MHz settings from calibrated 1 MHz settings in
                      ;INFO A, and sets DCOCTL and BCSCTL1 registers to the 8 MHz values,
                      ;so running at 8 MHz when return from this subroutine.

        mov.w   &CALDCO_1MHZ,   Calword                 ;set clock to 1 MHz
        bic.w   #0xF000,        Calword
        add.w   #0xB000,        Calword                 ;sets ACLK divider to 8
        mov.b   Calword,        &DCOCTL                 ;set clock to calibrated 1 MHz
        swpb    Calword                                 ;  with ACLOCK divider = 8
        mov.b   Calword,        &BCSCTL1
        mov.b   #LFXT1S_2,      &BCSCTL3                ;ACLK from VLO
        mov.w   #TACLR+MC_2+TASSEL_2,        &TACTL     ;set up and clear TA - 1 MHz Continuous
        mov.w   #CCIE+CAP+SCS+CCIS_1+CM_2,   &TACCTL0   ;capture on falling ACLK, IEn, sync

        mov.w   #64,            TotINTs                 ;total ACLK cycles per test
        mov.w   #0,             CurINT
        mov.w   #0,             MHzFlag                 ;start at 1 MHz (high byte), find 8 MHz (low)
        mov.w   #GIE+CPUOFF,        SR                  ;light sleep
        ret

TAIntSvc:

        cmp.w   #0,             CurINT                  ;beginning reading?
        jne     GetEnd                                  ;no
        mov.w   &TACCR0,        BegCnt                  ;yes, save captured TA value
        mov.w   TotINTs,        CurINT                  ;target # of interrupts to collect
        reti

GetEnd:

        dec.w   CurINT
        jz      Difference                              ;if end of collection
        bit.w   #0x8000,        MHzFlag                 ;is this the first collection at 1 MHz?
        jnz     NotFirst                                ;no
        cmp.w   #0x8000,        &TACCR0                 ;yes - past maximum desired sample time?
        jnc     NotFirst                                ;no, then keep going
        sub.w   CurINT,         TotINTs                 ;yes, end sample here at TotINTs-CurINT
        mov.w   #0,             CurINT                  ;future ones will also end here
        jmp     Difference                              ;end of collection

NotFirst:

        reti

Difference:

        bit.w   #0x8000,        MHzFlag                 ;still at 1 MHz?
        jnz     Test                                    ;no, we're testing 8MHz guess
        mov.w   &TACCR0,        Delta1                  ;yes, save ending value
        sub.w   BegCnt,         Delta1                  ;and calculate delta
        bis.w   #0x8000,        MHzFlag                 ;going to 8 or higher MHz - Bit 15 of flag
        mov.b   #RSEL_13+DIVA_3+XT2OFF, &BCSCTL1        ;probable range for 8 MHz = 13
        mov.b   #DIVS_3,                &BCSCTL2        ;SMCLK divider = 8 now.  Net 1 MHz

NewBCS:

        mov.w   #12,            LastEntry
        mov.w   #SLOW,          LastDir
        mov.b   #0x20,          &DCOCTL                 ;start near bottom

Reset1:

        bis.w   #TACLR,         &TACTL                  ;clear timer - want count back to zero
        reti

FoundIt:

        cmp.w   #0x8000,        MHzFlag                 ;did we just find 8 MHz?
        jnz     CheckNext                               ;no
        mov.b   &DCOCTL,        &0x023C                 ;yes - save 8 MHz values
        mov.b   &BCSCTL1,       &0x023D
        bic.b   #DIVA_3,        &0x023D                 ;Return ACLK divider to zero in copy

        inc.w   MHzFlag                                 ;update flag --  1 = working on 12 MHz
        mov.w   Delta1,         &0x0240                 ;now do 12 MHz - save Delta1
        clrc
        rrc.w   Delta1                                  ;divide by 2, add 1
        add.w   &0x0240,        Delta1                  ;Delta1 now 1.5x old Delta1
                                                        ;so 12 MHz clock should match that
        inc.b   &BCSCTL1                                ;expected range of 12 MHz is 14
        jmp     NewBCS                                  ;all dividers stay same

CheckNext:

        cmp.w   #0x8001,        MHzFlag                 ;did we just find 12 MHz?
        jnz     Set8                                    ;no, just finished 16 MHz, set clock back
        mov.b   &DCOCTL,        &0x023A                 ;yes - save 12 MHz values
        mov.b   &BCSCTL1,       &0x023B
        bic.b   #DIVA_3,        &0x023B                 ;Return ACLK divider to zero in copy

        inc.w   MHzFlag                                 ;update flag
        mov.w   &0x0240,        Delta1                  ;now do 16 MHz - restore Delta1
        bic.b   #DIVA_1,        &BCSCTL1                ;change ACLK divider from 8 to 4, input now 2x
                                                        ;so 16 MHz clock will give same count
        mov.b   #0,             &DCOCTL                 ;before going to RSEL 15
        inc.b   &BCSCTL1                                ;expected range of 16 MHz is 15
        nop
        jmp     NewBCS

Set8:

        mov.b   &DCOCTL,        &0x0238                 ;save 16 MHz values
        mov.b   &BCSCTL1,       &0x0239
        bic.b   #DIVA_3,        &0x0239                 ;Return ACLK divider to zero in copy

        dec.b   &BCSCTL1                                ;step down BCSCTL1
        nop
        dec.b   &BCSCTL1                                ;again
        nop
        mov.b   &0x023C,        &DCOCTL                 ;set clock to saved 8 MHz
        mov.b   &0x023D,        &BCSCTL1
        mov.w   #0,             &TACCTL0                ;Return BCS & TA to boot state at 8 MHz
        mov.w   #0,             &TACTL
        mov.b   #0,             &BCSCTL2
        mov.b   #0,             &BCSCTL3

Endcal:

        bic.w   #CPUOFF,        0(SP)                   ;CPU ON when return
        reti

Test:

        mov.w   &TACCR0,        Delta8                  ;test our guess - save ending result
        sub.w   BegCnt,         Delta8                  ;calculate delta at 8 MHz

        cmp.w   Delta8,         Delta1                  ;compare to initial delta at 1 MHz
        jz      FoundIt                                 ;same - we're done

        cmp.w   Delta8,         Delta1                  ;Delta1 vs Delta8
        jnc     TooFast

TooSlow:                                                ;Delta1 > Delta8 ---> clock too slow

        mov.w   #SLOW,          Dir                     ;need to go faster
        mov.w   Delta1,         ABSD8D1
        sub.w   Delta8,         ABSD8D1                 ;absolute difference between Delta8 and Delta1
        jmp     FindEntry

TooFast:                                                ;Delta8 > Delta1 ---> clock too fast

        mov.w   #FAST,          Dir                     ;need to go slower
        mov.w   Delta8,         ABSD8D1
        sub.w   Delta1,         ABSD8D1

FindEntry:                                              ;Find highest table entry that is =< ABSD8D1

        mov.w   #12,            Entry                   ;For/Next loop, step = -2 (one word)

Looking:

        cmp.w   ABSD8D1,        DiffTable(Entry)        ;Table entry - ABSD8D1
        jnc     GotIt                                   ;First time Delta above table entry
        sub.w   #2,             Entry                   ;Delta still below table entry. Try lower entry
        jnz     Looking                                 ;but if Entry at zero, we're done.

GotIt:  cmp.w   Dir,            LastDir                 ;same direction as last time?
        jnz     Crossover

DoNormal:                                               ;change DCO per table

        mov.b   &DCOCTL,        DCOTemp
        cmp     #FAST,          Dir
        jz      FallMore

AddMore:

        cmp.b   #0xF0,          DCOTemp                 ;already at F0, but still too slow?
        jnz     InRange
        inc.b   &BCSCTL1                                ;increase BCS
        jmp     NewBCS                                  ;start over

InRange:

        add.b   DCOTable(Entry),  DCOTemp               ;check if increase puts it over F0
        jc      Limit                                   ;CF set means > FF
        cmp.b   #0xF1,          DCOTemp
        jnc     NewDCO                                  ;CF clear means sum < F1, which is ok

Limit:

        mov.b   #0xF0,          DCOTemp                 ;DCO = limit

NewDCO:

        mov.b   DCOTemp,        &DCOCTL                 ;update DCOCTL

        mov.w   Dir,            LastDir
        mov.w   Entry,          LastEntry
        jmp     Reset1                                  ;test new setting

FallMore:

        cmp.b   #0,             DCOTemp                 ;already at zero, but still too fast?
        jnz     InRange2
        dec.b   &BCSCTL1                                ;decrease BCS
        jmp     NewBCS                                  ;start over

InRange2:

        sub.b   DCOTable(Entry),  DCOTemp
        jc      NewDCO                                  ;CF set means DCO will not be below zero
        mov.b   #0,             DCOTemp                 ;otherwise, make it zero
        jmp     NewDCO

Crossover:                                              ;from too slow to too fast, or vice versa

        cmp.w   #0,             Entry                   ;are current and last Entries both lowest?
        jnz     NotZeros
        cmp.w   #0,             LastEntry
        jnz     NotZeros

        cmp.w   #FAST,          Dir                     ;yes.  If now at faster one, accept it
        jz      FoundIt
        inc     &DCOCTL                                 ;otherwise, go back to faster one, and accept it

        jmp     FoundIt

NotZeros:

        cmp.w   #0,             LastEntry               ;find table entry one step below LastEntry
        jz      NoDec
        sub.w   #2,             LastEntry

NoDec:                                                  ;if crossover, next table entry will be lesser of
                                                        ;   current Entry value or one step below previous

        cmp.w   Entry,          LastEntry               ;lesser of
        jc      DoNormal
        mov.w   LastEntry,      Entry
        jmp     DoNormal

DiffTable:                                              ;how far off we are - number of clocks

        .dw     0,256,512,1024,2048,4096,8192

DCOTable:                                               ;how much to change DCOCTL by

        .dw     1,2,4,8,16,32,64

BSLCode:            ;;;;;;;;;;;BSL image goes here;;;;;;;;;;

;*******************************************************************************
; This is the "SPLIT" version of a custom Boot Strap Loader for the MSP430G2231. One part takes
; up all of INFOA, B and C except for the eight DCO calibration bytes at the top of INFOA, but it
; occupies none of INFOD.  The second part occupies 80 bytes of MAIN memory from 0xF800 to 0xF84F.
; The Windows console app BSL2231.EXE is used together with this BSL code to flash new firmware
; to the G2231 using a USB-to-serial adapter.  All applications flashed to the device using this
; version must begin at 0xF850, which should also be the reset vector shown in the firmware .hex
; file.  The Windows app will automatically change the reset vector shown in the .hex firmware
; file so that it points instead to the beginning of the BSL code at 0xF800.  If BSL flashing is
; not being invoked on reset, the BSL code will jump to 0xF850. The BSL uses a software UART
; to communicate with the Windows app.
;
; The original source code for this BSL appears in "MSP430BSL_1_00_12_00.zip" which is provided by
; Texas Instruments. See the copyright notice and related material at the beginning of this file.
;
; The protocol used here is the same as provided for in the original, with the
; following exceptions:
;
; 1.  P1.1 is used as both the RXD pin and the BSLPIN on the G2231.  A high reading
;     on BSLPIN when the pulldown resistor is enabled indicates an active USB connection
;     exists, and BSL flashing is being invoked.
;
; 2.  At the beginning of the protocol, if the custom BSL receives a character from the
;     Windows app master, but it is NOT the correct CMD_SYNC character, BSL will transmit
;     a NACK back to the master, then await another byte. This gives the master the option to
;     confirm that BSL is there and listening, and tells it which version of BSL is installed,
;     before sending the correct character to begin the flashing process.
;
;*******************************************************************************
                                            ; DO NOT CHANGE THESE - absolute locations
APPSTART     equ    0xF850                  ; Application code must begin here
FLASHSTART   equ    0xF850		    ; Lowest main flash address
BSLSTART     equ    0x1040                  ; BSL code in INFO memory
HIGHCODE     equ    0xF800                  ; BSL code in MAIN memory - BSL starts here
RAMM         equ    0x0200

;	    CPU registers used for BSL
BitCnt	     equ    R5
rxData	     equ    R6
rCHKSUM      equ    R7
rPoint	     equ    R8
rTemp	     equ    R9
rSource      equ    R11
rDest        equ    R12
rCount       equ    R13
rHighPoint   equ    R15

;	    Conditions for 9600 Baud HW/SW UART, MCLK 1 MHz
;	    1 MHz / 9600 = 104.15 Cycles per bit
BITTIME_5    equ    52			    ; 0.5 bit length
BITTIME      equ    104 		    ; 104 us
NACKCYCL     equ    BITTIME*2		    ; 2 bits low: start + 1 data bits
					    ;  0 + (1111 1110)b = 0xFE
ACKCYCL      equ    BITTIME*4		    ; 4 bits low: start + 3 data bits
					    ;  0 + (1111 1000)b = 0xF8
					    ; Meas: Puls 2us too long but no
					    ;  impact at 104us Bittime
Bit1	     equ    2
Bit2	     equ    4

RXD	     equ    Bit1       		    ; RXD on P1.1
TXD	     equ    Bit2            	    ; TXD on P1.2
BSLPIN	     equ    Bit1		    ; BSL entry on P1.1 HIGH (Use pulldown)

;	    Command number definition
CMD_SYNC     equ    0xBA                    ; signal to begin flashing

;-------------------------------------------------------------------------------
;	     BSL Application in INFO memory
;-------------------------------------------------------------------------------

;.org	     0x1040                      ; May be changed to image location, but
                                         ;   code always assembled as if at 0x1040
.org         0xFC00                      ; Possible image location

BASE:

;-------------------------------------------------------------------------------
MainBsl:	    ; BSL Main Loop  - Jump here from HIGHCODE portion
;-------------------------------------------------------------------------------
Wait4sync:  call    #((RxOneByte - BASE) + BSLSTART)

SyncCmd:    cmp     #CMD_SYNC,rxData	    ; Sync command received?
	    jne     LoadNACK		    ; Exit BSL if not Sync Byte

            mov.w   #HIGHCODE, rSource      ; copy high portion to RAM
            mov.w   rSource,   rHighPoint
            mov.w   #RAMM,     rDest
            call    #((Copy-BASE) + BSLSTART)

;-------------------------------------------------------------------------------
CmdFct_Erase:	    ; Erase main flash and restore interrupt vectors
;-------------------------------------------------------------------------------

EraseSeg:   mov.w   &FWKEY+MERAS,&FCTL1     ; MERAS=1. MAIN

	    mov.b   #0,&HIGHCODE	    ; Start erase with dummy write

WrtRstVec:  mov     #FWKEY+WRT,&FCTL1	    ; WRT=1. Write to segment
	    mov     #HIGHCODE,&0xFFFE       ; Point reset vector to BSL

            mov.w   #RAMM,         rSource  ; restore high portion from RAM
            mov.w   rHighPoint,    rDest
            call    #((Copy-BASE) + BSLSTART)

;-------------------------------------------------------------------------------
CmdFct_Write:	    ; Write (2048 - 2) Byte to Main memory
;-------------------------------------------------------------------------------

	    ; ================================================================
	    ; Ensure a minimum delay of 16 ms between SYNC and first byte
	    ; ================================================================

CFW_w4d:    call    #((RxOneByte - BASE) + BSLSTART)

CFW_Range:  cmp     #0xFFFE, rPoint	    ; Pointer to Reset Vector?
	    jeq     CFW_Done		    ; Skip and exit Write
	    mov.b   rxData,0(rPoint)	    ; Write 8 bit data to flash

CFW_COMM:
CFW_Xor:    xor.b   @rPoint+,rCHKSUM	    ; xor checksum and inc pointer
	    ;inc    rPoint		    ; no - inc done above w/ Auto increment
	    jmp     CFW_w4d		    ; wait for next byte

CFW_Done:   ; ================================================================
	    ; rx'ed byte for adress 0xffe (RESET) contains checksum
	    ; ================================================================
            mov.w   #(ACKCYCL/3),rTemp      ; /3 because 3 CPU cycles per loop
                                            ;  count required
            cmp.b   rxData, rCHKSUM	    ; XOR'ing calc checksum with sent
            jz      SendACK                 ;  should result in ZERO if match

LoadNACK:   mov.w   #(NACKCYCL/3),rTemp     ; Delay cycles to rTemp

SendACK:    bic.b   #TXD,&P1OUT             ; Initiate start bit
DelayACK:   dec.w   rTemp                   ; Decrement rTemp
            jnz     DelayACK                ; Delay over?
            bis.b   #TXD,&P1OUT             ; back high for remaining bits and stop bit

StartOver:  jmp     Wait4sync

Copy:
            mov.w   #EndHigh - RESET, rCount
MoveLoop:   mov.b   @rSource+, 0(rDest)
            inc.w   rDest
            dec.w   rCount
            jnz     MoveLoop
            ret

;-------------------------------------------------------------------------------
RxOneByte:  ; CCR0/UART ISR, rxData Buffer holds UART Data
;-------------------------------------------------------------------------------

	    mov.w   #((RX_Count - BASE) + BSLSTART),BitCnt	    ; RX_Count --> Branch Pointer

Wait4CCIFG: bit.w   #CCIFG, &TACCTL0	    ; Test CCIFG Bit - waiting for falling edge
	    jz	    Wait4CCIFG

	    add.w   #BITTIME,&TACCR0	    ; Bit time till next bit
	    bic.w   #CCIFG, &TACCTL0	    ; Clear IFG

	    mov.b   @BitCnt+,rTemp          ; Delta to next bit process
	    add     rTemp,PC                ; Branch to that process

RX_Edge:    bic.w   #CAP+CCIFG,&TACCTL0     ; Switch to Compare mode
	    add.w   #BITTIME_5,&TACCR0	    ; First Databit 1.5 Bits from edge
	    jmp     Wait4CCIFG		    ; Wait for TimerA to match

RX_Bit:     bit.w   #SCCI,&TACCTL0	    ; Get bit waiting in SCCI
	    rrc.b   rxData		    ; Store received bit - CF set if not zero
	    jmp     Wait4CCIFG		    ;

RX_Comp:    ; Byte received. Store and enable next rx cycle
	    bis.w   #CAP,&TACCTL0	    ; Switch to Capture mode
RxDone:     ret 			    ;

;-------------------------------------------------------------------------------
;	    Jump table for UART Bit detection
;-------------------------------------------------------------------------------
RX_Count:   .db   RX_Edge-RX_Edge	    ; Special for TA
	    .db   RX_Bit-RX_Edge	    ; RX First Data Bit
	    .db   RX_Bit-RX_Edge	    ;
	    .db   RX_Bit-RX_Edge	    ;
	    .db   RX_Bit-RX_Edge	    ;
	    .db   RX_Bit-RX_Edge	    ;
	    .db   RX_Bit-RX_Edge	    ;
	    .db   RX_Bit-RX_Edge	    ;
	    .db   RX_Bit-RX_Edge	    ;
	    .db   RX_Comp-RX_Edge	    ; RX Complete, process RX data

;-------------------------------------------------------------------------------
;	    Portion of BSL code in MAIN memory
;-------------------------------------------------------------------------------

.org         0xF800                         ; May be changed to image location, but
                                            ;   code always assembled as if at 0xF800
HIGHBASE:
;-------------------------------------------------------------------------------
;	    Start of BSL Code
;-------------------------------------------------------------------------------

RESET:
            mov.b   #0,      &P1OUT         ; pulldown resistor
	    bis.b   #BSLPIN, &P1REN	    ; enable resistor
	    bit.b   #BSLPIN, &P1IN	    ; Pin high invokes BSL
            mov.b   #0, &P1REN              ; restore P1REN

            jz	    APPSTART                ; pin low - jump to app

InvokeBsl:  mov.w   #0x280,SP		    ; Init Stackpointer to top of RAM
					    ; RAM: 0x27f - 0x200

UnlockFlash: mov.w  #FWKEY,&FCTL3	    ; LOCK=0, all others 0, INFOA stays Hi

StopWDT:    mov.w   #WDTPW+WDTHOLD,&WDTCTL  ; Stop Watchdog Timer

SetupDCO:   ; Set DCO to calibrated 1 MHz:
	    mov.b   &CALDCO_1MHZ, &DCOCTL   ; Set DCO step + modulation
            mov.b   &CALBC1_1MHZ, &BCSCTL1  ; Set range

SetupPins:  bis.b   #RXD,&P1SEL 	    ; Rx pin special function for TimerA
	    bis.b   #TXD,&P1OUT             ; Tx pin normally high
	    bis.b   #TXD,&P1DIR             ; Turn on output

SetupTA0:   ;CC Input0: Capture on falling Edge
	    mov.w   #CM_2+CCIS_0+SCS+CAP,&TACCTL0
	    ;Timer in Continuous mode, Clock Source is SMCLK
	    bis.w   #TASSEL_2+MC_2+TACLR,&TACTL

InitRx:
	    mov     #FLASHSTART, rPoint	    ; Point to beginning flash location = 0xF850
	    clr     rCHKSUM		    ; Init Checksum

            br      #BSLSTART               ; jump to BSL code in INFO memory

EndHigh:                         ;Application should start here (F850)

;Set Vectors

        .org    TIMERA0_VECTOR
        .dw     TAIntSvc

        .org    RESET_VECTOR
        .dw     PowerUp
